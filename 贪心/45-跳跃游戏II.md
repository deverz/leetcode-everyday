[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```
45. 跳跃游戏 II
给你一个非负整数数组nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2
```

```
解题思路：https://leetcode-cn.com/problems/jump-game-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-10/
从数组的第 0 个位置开始跳，跳的距离小于等于数组上对应的数。
求出跳到最后个位置需要的最短步数。比如上图中的第 0 个位置是 2，那么可以跳 1 个距离，或者 2 个距离，
我们选择跳 1 个距离，就跳到了第 1 个位置，也就是 3 上。然后我们可以跳 1，2，3 个距离，我们选择跳 3 个距离，
就直接到最后了。所以总共需要 2 步。
```
```go
func jump(nums []int) int {
	// 每一次都默认跳最远距离
	end := 0  // 记录可以跳到的最远边界位置
	max := 0  // 记录可以跳到的最远距离
	step := 0 // 记录跳到末尾需要的步数
	// 遍历数组，之所以遍历到len(nums)-2，是因为在i=0时，step已经加1了，
	// 如果最后刚好跳到了最后一个元素，那么又得加1，等于是多加了
	for i := 0; i < len(nums)-1; i++ {
		// 每走一步就更新本次可达的最远距离
		if (nums[i] + i) > max {
			max = nums[i] + i
		}
		// 当遍历到之前计算的边界时，给边界重新赋值，并将步数加1
		if i == end {
			end = max
			step++
		}
	}
	return step
}
```